"""Module for LLM answer generation chain."""

from typing import Any, Optional

from langchain_core.documents import Document
from langchain_core.runnables import Runnable, RunnableConfig, RunnablePassthrough
from langchain_core.output_parsers import StrOutputParser

from rag_core_api.impl.graph.graph_state.graph_state import AnswerGraphState
from rag_core_lib.runnables.async_runnable import AsyncRunnable
from rag_core_lib.impl.langfuse_manager.langfuse_manager import LangfuseManager

RunnableInput = AnswerGraphState
RunnableOutput = str


class AnswerGenerationChain(AsyncRunnable[RunnableInput, RunnableOutput]):
    """Base class for LLM answer generation chain."""

    def __init__(self, langfuse_manager: LangfuseManager):
        """Initialize the AnswerGenerationChain.

        Parameters
        ----------
        langfuse_manager : LangfuseManager
            Manager instance for handling Langfuse operations and monitoring
        """
        self._langfuse_manager = langfuse_manager

    @staticmethod
    def _format_buckets(docs: list[Document]) -> dict[str, list[tuple[str, Document]]]:
        """Classify documents into buckets for B‑Plan, Festsetzungen, LBO and Other."""

        def classify(doc: Document) -> tuple[str, str]:
            meta = getattr(doc, "metadata", {}) or {}
            url = str(meta.get("document_url", ""))
            name = str(meta.get("document", ""))
            hint_source = name or url
            low = f"{url} {name}".lower()
            if "bebauungsplan" in low and "festsetzung" in low:
                return ("BPLAN_FESTSETZUNGEN", hint_source)
            if "bebauungsplan" in low:
                return ("BPLAN", hint_source)
            if "landesbauordnung" in low or " lbo" in low or "/lbo/" in low or low.endswith("lbo.pdf"):
                return ("LBO", hint_source)
            return ("OTHER", hint_source)

        buckets: dict[str, list[tuple[str, Document]]] = {
            "BPLAN_FESTSETZUNGEN": [],
            "BPLAN": [],
            "LBO": [],
            "OTHER": [],
        }
        for d in docs:
            category, hint = classify(d)
            buckets.setdefault(category, []).append((hint, d))
        return buckets

    @staticmethod
    def _render_sections(buckets: dict[str, list[tuple[str, Document]]]) -> str:
        """Render a full context string with sections in priority order."""
        sections: list[str] = []

        def render_section(title: str, entries: list[tuple[str, Document]]):
            if not entries:
                return
            sections.append(f"[{title}]")
            for hint, doc in entries:
                prefix = f"Quelle: {hint}" if hint else "Quelle: unbekannt"
                sections.append(f"- {prefix}\n{doc.page_content}")

        # Order: Festsetzungen (B-Plan) -> B-Plan -> LBO -> Other
        render_section("Bebauungsplan – Festsetzungen", buckets.get("BPLAN_FESTSETZUNGEN", []))
        render_section("Bebauungsplan (lokal)", buckets.get("BPLAN", []))
        render_section("Landesbauordnung (LBO)", buckets.get("LBO", []))
        render_section("Weitere Quellen", buckets.get("OTHER", []))

        return "\n\n---\n\n".join(sections) if sections else ""

    @staticmethod
    def _render_lbo_only(docs: list[Document]) -> str:
        """Render a context string that contains only LBO documents, grouped per source."""
        # Reuse the bucketizer and only render the LBO bucket
        buckets = AnswerGenerationChain._format_buckets(docs)
        lbo_entries = buckets.get("LBO", [])
        if not lbo_entries:
            return ""
        lines: list[str] = ["[Landesbauordnung (LBO)]"]
        for hint, doc in lbo_entries:
            prefix = f"Quelle: {hint}" if hint else "Quelle: unbekannt"
            lines.append(f"- {prefix}\n{doc.page_content}")
        return "\n\n".join(lines)

    async def ainvoke(
        self, chain_input: RunnableInput, config: Optional[RunnableConfig] = None, **kwargs: Any
    ) -> RunnableOutput:
        """
        Asynchronously invokes the chain with given input.

        Parameters
        ----------
        chain_input : RunnableInput
            The input to be processed by the chain.
        chain_config : Optional[RunnableConfig]
            Configuration for the chain execution (default None).
        **kwargs : Any
            Additional keyword arguments passed to the chain.

        Returns
        -------
        RunnableOutput
            The output generated by the chain.

        Raises
        ------
        ChainError
            If an error occurs during chain execution.
        """
        return await self._create_chain().ainvoke(chain_input, config=config)

    def _create_chain(self) -> Runnable:
        return (
            RunnablePassthrough.assign(
                context=(
                    lambda x: self._render_sections(
                        self._format_buckets(
                            # Prefer bplan_documents if present for ordering; fall back to full docs
                            (x.get("bplan_documents") or []) + (x.get("lbo_documents") or []) + [
                                d for d in x["langchain_documents"] if d not in (x.get("bplan_documents") or []) and d not in (x.get("lbo_documents") or [])
                            ]
                        )
                    )
                ),
                lbo_context=(
                    lambda x: self._render_lbo_only(
                        # Use lbo_documents if present; otherwise filter from all
                        (x.get("lbo_documents") or [
                            d for d in x["langchain_documents"]
                            if (str((getattr(d, "metadata", {}) or {}).get("document_url", "")) + " " + str((getattr(d, "metadata", {}) or {}).get("document", ""))).lower().find("landesbauordnung") != -1
                            or (" lbo" in (str((getattr(d, "metadata", {}) or {}).get("document_url", "")).lower() + " " + str((getattr(d, "metadata", {}) or {}).get("document", "")).lower()))
                            or ("/lbo/" in (str((getattr(d, "metadata", {}) or {}).get("document_url", "")).lower() + " " + str((getattr(d, "metadata", {}) or {}).get("document", "")).lower()))
                        ])
                    )
                ),
            )
            | self._langfuse_manager.get_base_prompt(self.__class__.__name__)
            | self._langfuse_manager.get_base_llm(self.__class__.__name__)
            | StrOutputParser()
        )
